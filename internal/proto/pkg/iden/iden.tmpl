package iden

import (
	"context"
	"crypto/aes"
	"encoding/base64"
	"encoding/json"
	"log/slog"

	"{{.Module}}/pkg/log"

	"github.com/noble-gase/ne/crypts"
	"github.com/noble-gase/ne/helper"
	"github.com/spf13/viper"
)

const (
	IdenId    = "iden_id"
	IdenToken = "iden_token"
)

// Iden 授权身份
type Iden struct {
	Id    int64  `json:"i,omitempty"`
	Token string `json:"t,omitempty"`
}

// FromAuthToken 解析授权Token
func FromAuthToken(ctx context.Context, token string) Iden {
	var iden Iden

	cipherText, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		log.Error(ctx, err, slog.String("token", token))
		return iden
	}

	key := []byte(viper.GetString("app.secret"))
	plainText, err := crypts.DecryptCBC(key, key[:aes.BlockSize], cipherText)
	if err != nil {
		log.Error(ctx, err, slog.String("token", token))
		return iden
	}

	if err = json.Unmarshal(plainText, &iden); err != nil {
		log.Error(ctx, err, slog.String("token", token), slog.String("data", string(plainText)))
	}
	return iden
}

// ToAuthToken 生成授权Token
func ToAuthToken(ctx context.Context, id int64, token string) (string, error) {
	iden := Iden{
		Id:    id,
		Token: token,
	}

	b, err := json.Marshal(iden)
	if err != nil {
		return "", helper.Error(ctx, err, slog.Int64("id", id), slog.String("token", token))
	}

	key := []byte(viper.GetString("app.secret"))
	ct, err := crypts.EncryptCBC(key, key[:aes.BlockSize], b)
	if err != nil {
		return "", helper.Error(ctx, err, slog.Int64("id", id), slog.String("token", token))
	}
	return ct.String(), nil
}

func GetIdenId(ctx context.Context) int64 {
	return helper.MDIntFromCtx[int64](ctx, IdenId)
}

func GetIdenToken(ctx context.Context) string {
	return helper.MDStrFromCtx(ctx, IdenToken)
}
