package middleware

import (
	"bytes"
	"io"
	"log/slog"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/go-chi/chi/v5/middleware"
	"github.com/noble-gase/ne/helper"
	"github.com/noble-gase/ne/result"
	"github.com/tidwall/pretty"
)

const MaxLogSize = 32 << 10 // 32KB

var bufPool = sync.Pool{
	New: func() any {
		return bytes.NewBuffer(make([]byte, 0, 4<<10)) // 4KB
	},
}

// Log 日志中间件
func Log(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		now := time.Now()

		body := "<nil>"

		buf := bufPool.Get().(*bytes.Buffer)
		buf.Reset()
		defer func() {
			if buf.Cap() > MaxLogSize {
				return
			}
			buf.Reset()
			bufPool.Put(buf)
		}()

		// 自定义响应
		ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)
		ww.Tee(helper.LimitWriter(buf, MaxLogSize))

		defer func() {
			slog.InfoContext(r.Context(), r.RequestURI,
				slog.String("method", r.Method),
				slog.String("ip", r.RemoteAddr),
				slog.Any("header", r.Header),
				slog.String("request", body),
				slog.String("response", strings.TrimSuffix(buf.String(), "\n")),
				slog.Int("status", ww.Status()),
				slog.String("duration", time.Since(now).String()),
			)
		}()

		if r.Body != nil && r.Body != http.NoBody {
			b, err := io.ReadAll(r.Body)
			if err != nil {
				slog.ErrorContext(r.Context(), "request body read failed", slog.String("error", err.Error()))
				result.Err(err).JSON(w, r)
				return
			}
			r.Body.Close()

			if len(b) > MaxLogSize {
				body = string(b[:MaxLogSize])
			} else {
				if helper.ContentType(r.Header) == helper.ContentJSON {
					body = string(pretty.Ugly(b))
				} else {
					body = string(b)
				}
			}
			r.Body = io.NopCloser(bytes.NewReader(b))
		}

		next.ServeHTTP(ww, r)
	})
}
