package iden

import (
	"context"
	"crypto/aes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log/slog"

	"github.com/noble-gase/ne/conv"
	"github.com/noble-gase/ne/crypts"
	"github.com/noble-gase/ne/metadata"
	"github.com/spf13/viper"
)

const (
	IdenId    = "iden_id"
	IdenToken = "iden_token"
)

// Iden 授权身份
type Iden struct {
	Id    int64  `json:"i,omitempty"`
	Token string `json:"t,omitempty"`
}

// FromAuthToken 解析授权Token
func FromAuthToken(ctx context.Context, token string) Iden {
	var iden Iden

	cipherText, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		slog.ErrorContext(ctx, "[AuthToken] base64.Decode failed", slog.String("error", err.Error()))
		return iden
	}

	key := []byte(viper.GetString("app.secret"))
	plainText, err := crypts.DecryptCBC(key, key[:aes.BlockSize], cipherText)
	if err != nil {
		slog.ErrorContext(ctx, "[AuthToken] crypts.DecryptCBC failed", slog.String("error", err.Error()))
		return iden
	}

	if err = json.Unmarshal(plainText, &iden); err != nil {
		slog.ErrorContext(ctx, "[AuthToken] json.Unmarshal failed", slog.String("error", err.Error()))
	}
	return iden
}

// ToAuthToken 生成授权Token
func ToAuthToken(id int64, token string) (string, error) {
	iden := Iden{
		Id:    id,
		Token: token,
	}

	b, err := json.Marshal(iden)
	if err != nil {
		return "", fmt.Errorf("json.Marshal: %w", err)
	}

	key := []byte(viper.GetString("app.secret"))
	ct, err := crypts.EncryptCBC(key, key[:aes.BlockSize], b)
	if err != nil {
		return "", fmt.Errorf("crypts.EncryptCBC: %w", err)
	}
	return ct.String(), nil
}

func GetIdenId(ctx context.Context) int64 {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return 0
	}
	vals := md.Get(IdenId)
	if len(vals) == 0 {
		return 0
	}
	return conv.StrToInt[int64](vals[0])
}

func GetIdenToken(ctx context.Context) string {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return ""
	}
	vals := md.Get(IdenToken)
	if len(vals) == 0 {
		return ""
	}
	return vals[0]
}
