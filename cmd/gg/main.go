package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/noble-gase/og/internal"
	"github.com/spf13/cobra"
)

const suffix = "_getter.go"

type GenBody struct {
	PkgName string
	Imports map[string]struct{}
	Structs []Struct
}

// Struct represents a Go struct
type Struct struct {
	Receiver string
	Name     string
	Fields   []Field
}

// Field represents a struct field
type Field struct {
	Name    string
	Type    string
	Default Default
}

type Default struct {
	GenType *GenType // æ³›å‹
	Value   string
}

type GenType struct {
	Ident string
	Type  string
}

// Template for generating Get methods
const tmpl = `package {{ .PkgName }}

// Code generated by gg; DO NOT EDIT.

{{- with .Imports }}
{{- $len := len . }}
{{- if gt $len 0 }}

{{- if eq $len 1 }}
{{- range $k, $v := . }}

import "{{ $k }}"

{{- end }}
{{- else }}

import (
{{- range $k, $v := . }}
	"{{ $k }}"
{{- end }}
)

{{- end }}
{{- end }}

{{- end }}

{{- range $s := .Structs }}

{{- with $s.Fields }}
{{- $len := len . }}
{{- if gt $len 0 }}

// Get methods for {{ $s.Name }}

{{- range . }}

func ({{ $s.Receiver }} *{{ $s.Name }}) Get{{ .Name }}() {{ .Type }} {
	if {{ $s.Receiver }} != nil {
		return {{ $s.Receiver }}.{{ .Name }}
	}
	{{- if .Default.GenType }}
	var v {{ .Default.GenType.Ident }}
	return v
	{{- else }}
	return {{ .Default.Value }}
	{{- end }}
}

{{- end }}

{{- end }}

{{- end }}

{{- end }}
`

func main() {
	var paths []string

	cmd := &cobra.Command{
		Use:     "gg",
		Short:   "ç”ŸæˆGetæ–¹æ³•^_^",
		Long:    "ä¸ºç»“æ„ä½“ç”Ÿæˆ`Get`æ–¹æ³•ï¼Œé¿å…ç©ºæŒ‡é’ˆå¯¼è‡´Panic",
		Version: "v0.1.0",
		Example: internal.CmdExamples(
			"ğŸ‘‰ -- CLI --",
			"gg --path .",
			"gg --path a/b/c",
			"gg --path xxx.go",
			"",
			"ğŸ‘‰ -- go:generate --",
			"//go:generate gg --path .",
			"//go:generate gg --path a/b/c",
			"//go:generate gg --path xxx.go",
		),
		Run: func(cmd *cobra.Command, args []string) {
			for _, path := range paths {
				genGetter(filepath.Clean(path))
			}
		},
	}
	// æ³¨å†Œå‚æ•°
	cmd.Flags().StringSliceVarP(&paths, "path", "p", nil, "æ–‡ä»¶/ç›®å½•")
	// æ‰§è¡Œ
	_ = cmd.Execute()
}

func genGetter(path string) {
	stat, err := os.Stat(path)
	if err != nil {
		log.Fatalln("os.Stat", internal.FmtErr(err))
	}

	var dir string
	if stat.IsDir() {
		dir = path
	} else {
		dir = filepath.Dir(path)
	}

	fset := token.NewFileSet()

	// Parse package files
	pkgMap, err := parser.ParseDir(fset, dir, func(info fs.FileInfo) bool {
		// è¿‡æ»¤æ‰ `_getter.go` ç»“å°¾çš„æ–‡ä»¶
		if strings.HasSuffix(info.Name(), suffix) {
			return false
		}
		return true
	}, parser.AllErrors)
	if err != nil {
		log.Fatalln("parser.ParseDir", internal.FmtErr(err))
	}

	var files []*ast.File
	nodeMap := make(map[string]*ast.File)
	for _, pkg := range pkgMap {
		for k, v := range pkg.Files {
			files = append(files, v)
			nodeMap[k] = v
		}
	}

	// Type-checks a package and returns the resulting package object
	info := &types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
	}
	conf := &types.Config{
		Importer:                 importer.ForCompiler(fset, "source", nil),
		IgnoreFuncBodies:         true,
		DisableUnusedImportCheck: true,
	}
	if _, err = conf.Check("", fset, files, info); err != nil {
		log.Fatalln("conf.Check", internal.FmtErr(err))
	}

	// Generate file
	if !stat.IsDir() {
		if node, ok := nodeMap[path]; ok {
			genFile(node, info, path)
		}
		return
	}

	// Generate files
	for filename, node := range nodeMap {
		genFile(node, info, filename)
	}
}

func genFile(node *ast.File, info *types.Info, filename string) {
	sourceFile := filepath.Clean(filename)

	gen := GenBody{
		PkgName: node.Name.Name,
		Imports: make(map[string]struct{}),
		Structs: make([]Struct, 0),
	}

	// Walk through the AST
	ast.Inspect(node, func(n ast.Node) bool {
		// Find type declarations
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		// Check if it's a struct
		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Generics identifier
		var gt []GenType
		if ts.TypeParams != nil {
			for _, field := range ts.TypeParams.List {
				typeName := info.TypeOf(field.Type).String()
				for _, ident := range field.Names {
					gt = append(gt, GenType{
						Ident: ident.Name,
						Type:  typeName,
					})
				}
			}
		}

		// Analyze struct
		imports, data := analyzeStruct(info, ts, st, gt)
		for path := range imports {
			gen.Imports[path] = struct{}{}
		}
		gen.Structs = append(gen.Structs, data)

		return true
	})

	if len(gen.Structs) == 0 {
		return
	}

	// Generate code
	var buf bytes.Buffer
	t := template.Must(template.New("getters").Parse(tmpl))
	if err := t.Execute(&buf, gen); err != nil {
		log.Fatalln("t.Execute", internal.FmtErr(err))
	}

	// Write to a file
	outputFile := strings.ReplaceAll(sourceFile, ".go", suffix)
	if err := os.WriteFile(outputFile, buf.Bytes(), 0o755); err != nil {
		log.Fatalln("os.WriteFile", internal.FmtErr(err))
	}
	fmt.Println("Generated code saved to", outputFile)
}

func analyzeStruct(info *types.Info, ts *ast.TypeSpec, st *ast.StructType, gt []GenType) (map[string]struct{}, Struct) {
	name := ts.Name.String()
	receiver := "s"
	if name != "<nil>" {
		receiver = strings.ToLower(name[:1])
	}
	// Generics identifier
	if len(gt) != 0 {
		name += "["
		name += gt[0].Ident
		for _, v := range gt[1:] {
			name += ", "
			name += v.Ident
		}
		name += "]"
	}

	// Collect fields and imports
	fields := make([]Field, 0, len(st.Fields.List))
	imports := make(map[string]struct{})
	for _, field := range st.Fields.List {
		if len(field.Names) != 0 {
			fieldType := info.TypeOf(field.Type)
			// åŒ…è·¯å¾„
			for _, path := range analyzeImport(fieldType) {
				imports[path] = struct{}{}
			}
			// å­—æ®µç±»å‹
			typeName := analyzeTypeName(fieldType)
			for _, name := range field.Names {
				fields = append(fields, Field{
					Name:    name.Name,
					Type:    typeName,
					Default: getTypeValue(field.Type, typeName, fieldType.Underlying().String(), gt),
				})
			}
		}
	}

	return imports, Struct{
		Receiver: receiver,
		Name:     name,
		Fields:   fields,
	}
}

func analyzeImport(fieldType types.Type) []string {
	var imports []string
	switch v := fieldType.(type) {
	case *types.Alias:
		if pkg := v.Obj().Pkg(); pkg != nil && len(pkg.Path()) != 0 {
			imports = append(imports, pkg.Path())
		}
	case *types.Named:
		if pkg := v.Obj().Pkg(); pkg != nil && len(pkg.Path()) != 0 {
			imports = append(imports, pkg.Path())
		}
	case *types.Pointer:
		imports = append(imports, analyzeImport(v.Elem())...)
	case *types.Slice:
		imports = append(imports, analyzeImport(v.Elem())...)
	case *types.Map:
		imports = append(imports, analyzeImport(v.Key())...)
		imports = append(imports, analyzeImport(v.Elem())...)
	}
	return imports
}

func analyzeTypeName(fieldType types.Type) string {
	var name string
	switch v := fieldType.(type) {
	case *types.Alias:
		pkg := v.Obj().Pkg()
		if pkg != nil && len(pkg.Path()) != 0 {
			name = fmt.Sprintf("%s.%s", pkg.Name(), v.Obj().Name()) // åªä¿ç•™åŒ…å + ç±»å‹å
		} else {
			name = v.Obj().Name()
		}
	case *types.Named:
		pkg := v.Obj().Pkg()
		if pkg != nil && len(pkg.Path()) != 0 {
			name = fmt.Sprintf("%s.%s", pkg.Name(), v.Obj().Name()) // åªä¿ç•™åŒ…å + ç±»å‹å
		} else {
			name = v.Obj().Name()
		}
	case *types.Pointer:
		name = "*" + analyzeTypeName(v.Elem()) // é€’å½’å¤„ç†æŒ‡é’ˆç±»å‹
	case *types.Slice:
		name = "[]" + analyzeTypeName(v.Elem()) // é€’å½’å¤„ç†åˆ‡ç‰‡ç±»å‹
	case *types.Map:
		name = fmt.Sprintf("map[%s]%s", analyzeTypeName(v.Key()), analyzeTypeName(v.Elem())) // å¤„ç† map ç±»å‹
	default:
		name = fieldType.String() // å…¶ä»–ç±»å‹ï¼ˆåŸºæœ¬ç±»å‹ç­‰ï¼‰
	}
	return name
}

// è·å–ç±»å‹çš„é»˜è®¤å€¼
func getTypeValue(expr ast.Expr, fieldType, underlyingType string, gt []GenType) Default {
	switch expr.(type) {
	case *ast.Ident, *ast.SelectorExpr: // åŸºæœ¬ç±»å‹ || è‡ªå®šä¹‰ç±»å‹ || åŒ…è·¯å¾„ç±»å‹
		return getDefaultValue(fieldType, underlyingType, gt)
	case *ast.ArrayType, *ast.MapType, *ast.InterfaceType, *ast.StarExpr:
		return Default{Value: "nil"}
	default:
		return Default{Value: "unknown"}
	}
}

func getDefaultValue(fieldType, underlyingType string, gt []GenType) Default {
	// æ³›å‹å­—æ®µ
	for _, v := range gt {
		if fieldType == v.Ident {
			return Default{
				GenType: &GenType{
					Ident: v.Ident,
					Type:  v.Type,
				},
			}
		}
	}
	// æ™®é€šå­—æ®µ
	switch underlyingType {
	case "string":
		return Default{Value: `""`}
	case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64":
		return Default{Value: "0"}
	case "float32", "float64":
		return Default{Value: "0"}
	case "bool":
		return Default{Value: "false"}
	case "any":
		return Default{Value: "nil"}
	default:
		if strings.HasPrefix(underlyingType, "*") ||
			strings.HasPrefix(underlyingType, "interface") ||
			strings.HasPrefix(underlyingType, "[]") ||
			strings.HasPrefix(underlyingType, "map") {
			return Default{Value: "nil"}
		}
		if strings.HasPrefix(underlyingType, "struct") {
			return Default{Value: fmt.Sprintf("%s{}", fieldType)}
		}
		return Default{Value: "unknown"}
	}
}
